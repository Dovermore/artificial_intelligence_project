\documentclass[11pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{setspace}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{listings}
\usepackage{wrapfig}
\usepackage{hyperref}
\usepackage[left=1cm, right=1cm, top=1cm, bottom=2cm]{geometry}

%\setlength{\parskip}{0em}
\setstretch{0.3}

\algdef{SE}[SUBALG]{Indent}{EndIndent}{}{\algorithmicend\ }%
\algtext*{Indent}
\algtext*{EndIndent}

\newcommand{\algorithmautorefname}{Algorithm}

\begin{document}
    \begin{center}
        \large \textbf{Problem, Search and beyond}
        
        \normalsize Chuanyuna Liu 884140, Zhuoqun Huang 908525
    \end{center}
    \section{Problem}
    \subsection{General Problem}
    We formulate our problem with the following five concepts:
    \begin{itemize}
        \itemsep0em
        \item \textbf{State($\mathbb{S}$)} including a \textbf{initial state ($s_0$)} the agent begins with
        \item \textbf{Actions($\mathbb{A}$)} available to agent at each State
        \item \textbf{Transition function ($F:\mathbb{S}\times \mathbb{A}\rightarrow \mathbb{S}$)} that takes a (state, action) pair and return a new state
        \item \textbf{Goal Test($GT:S\rightarrow \{True, False\}$)} that takes a state $s$ and return true if $s\in S_{goal}$, the \textbf{Goal State} of the problem.
        \item \textbf{Path Cost ($C:\mathbb{S}\times \mathbb{S}\rightarrow \mathbb{R}$)} That takes two states and return cost moving from one to another
    \end{itemize}
    \vspace{-15pt}
    \subsection{Single-player Chexers}
    In this section, we formally describe how the above framework fits the Chexers game.
    \begin{itemize}
        \itemsep0em
        \item Denote set of pieces with $\mathbb{P}=\{(r, q, t)\}$. \\
        where
        \begin{align*}
            \text{$r, q, -(r+q)\in [-3, 3]$ denotes the location on board.}\\
            \text{$t\in \{red, blue, green, block\}$ stands for type of piece.}    
        \end{align*}
        
        \item $\mathbb{S} := \{p_i\in \mathbb{P}, t_b|i\le n\}$ where $n$ is number of pieces on board, where $t_b$ is the searching type.*
        \item $\mathbb{A} := \{(Move,p_i), (Jump, p_i), (Exit, p_i)\}, \forall\ p_i $ where$\ t(p_i)=t_b. | \mathbb{A}_s| \le 6n_p\ \forall s$.
        \item $f(s, a) := s'$. where $s'$ differs exactly by one piece $r(p_{i,s}), q(p_{i,s}) \ne r(p_{i,s'}), q(p_{i,s'})$ or $p_i\notin s'$
        \item $c(s, s') := 1, \forall s, s'\ \text{if}\ \exists a\ \text{such that} f(s, a) = s'$
        \item $gt(s) = True$ if $\nexists p_i$ such that $t(p_i) = t_b$
    \end{itemize}
    *Initial State $s_0$ given by problem specification.
    \vspace{-5pt}
    \section{Search}
        \subsection{preliminary}
        We use the following \autoref{a_star}, to search for our goal. Based on our problem specification, we have all required components except for \textbf{H($node$)}, so we will propose one type of \textbf{H} we found to be most effective of all and compare it against \textbf{Null $H=0$} and \textbf{bad H $H_{bad}$($node$)}\footnote{In following analysis, $b$ for \textbf{branching factor}, $d$ \textbf{for depth}}.
        \begin{algorithm}[ht]
            \footnotesize
            \caption{General A* algorithm}\label{a_star}
            \begin{algorithmic}[1]
                \Statex PRIORITY-QUEUE \Comment{\textbf{Min} Priority Queue (min key)}
                \Statex  \hskip2.0em ADD($q$, $key$, $value$), \Comment{Add (key, value) to q. If value exists, update the key}
                \Statex  \hskip2.0em POP($q$) \Comment{Pop the value with \textbf{least} key}
                \Statex  \hskip2.0em GET($q$, $value$) \Comment{Get the key associated with a value}
                \Statex \Comment{All above Queue operations can operate in $\Theta(1)$}
                \Statex
                \Statex NODE \Comment{stores associated \textbf{state} and its \textbf{parent}}
                \Require EXPAND($node$)\Comment{expand a \textbf{node} to get it's \textbf{children}}
                \Require G($node$)\Comment{get \textbf{total cost} arriving this node}
                \Require H($node$) \Comment{Computes an \textbf{admissible estimation} of cost to goal state}
                \Require C($node1$, $node2$) \Comment{Give Path cost arriving node 2 from node 1}
                \Procedure{A*}{$problem$, $initial$}
                \State $openSet \gets$ PRIORITY-QUEUE(H($initial$),  $initial$)
                \State $closedSet \gets$ \{\}
                \While{$openSet$ \textbf{is not} empty} \Comment{$O(d)$}
                    \State $node \gets POP(openSet)$
                    \State $ADD(closedSet, node)$
                    \If {GOAL-TEST($node$) \textbf{is} True}
                        \State \textbf{return} $node$
                    \EndIf
                    \For {$child$ \textbf{in} EXPAND($node$)}  \Comment{$O(b)$}
                        \State $cost$ = G($node$) + C($node$, $child$) + H($child$)
                        \If {$child$ \textbf{in} $closedSet$}
                            continue
                        \ElsIf {$child$ not in $openSet$ \textbf{or} cost $<$ GET($openSet$, $child$)}
                            \State ADD(openSet, cost, child)
                        \EndIf
                    \EndFor
                \EndWhile
                \State \textbf{return} no solution
                \EndProcedure\\
                All operations $O(1)$ unless explicitly stated, we denote the complexity of search for problem also here.
            \end{algorithmic}
        \end{algorithm}
    \vspace{-10pt}
    \subsection{Heuristic}
        \paragraph{As a Problem} We propose wing problem definition for mapping a good heuristic value for each pieces and we define $H(s) = \sum_{p_i}h(p_i), \forall p_i$ that $t(p_i) = t_b$ after relaxing the problem to be: a piece can choose freely between \textbf{move}, \textbf{jump} regardless normal constrains and \textbf{cannot} move on blocks.
        \begin{itemize}
            \itemsep0em   
            \item $\mathbb{S} := \{(cost_i, position_i)|location_i\in board\}$*,
            \item $\mathbb{A} :$ for $pos_i$ with $cost_i=min({cost_n})$, $\forall$ $pos_{j\ne i} $ reachable from $pos_i$ and $cost_j > cost_i+1$. Update $(pos_j, cost_i + 1)$. If $\nexists pos_j$, remove $(pos_i, cost_i)$ from $s$ and put $h(pos_i) = cost_i$
            \item $c(s, s')=0$ and $f(s,a)$ follows definition in $\mathbb{A}$
            \item $gt(s')=True$ if $s' = \emptyset$
        \end{itemize}
        *$s_0 = \{(1, pos_i)|can\_exit(pos_i) = True\} | \{(\infty, pos_i)|can\_exit(pos_i) = False\}$
        \vspace{-10pt}
        \paragraph{Heuristic problem solution} Finding heuristic is straight forward with the given above problem definition. Supporting all the given operations to \ref{a_star}, and you should end up with a complete heuristic map.
        \vspace{-10pt}
        \paragraph{Admissible?} The algorithm is guaranteed to provide us with a admissible cost estimation for each game state:\\
    - The relaxed rule let pieces always able to jump.\\
    - This will in all cases reduce the number of action taken, by always increasing the distance a piece can move.
    \vspace{-10pt}
    \subsection{Property of search}
        \paragraph{Efficiency} The efficiency of A* algorithm heavily depends on how accurate the heuristic is. As we can see from the example below. Our heuristic is very close to the real cost.    
        \begin{wrapfigure}{r}{0.3\textwidth}
            \vspace{-35pt}
                \begin{center}
                    \includegraphics[width=0.3\textwidth]{heuristic.png}
                    \label{fig:heurstics}
                \end{center}
            \caption{Map formed by heuristic}
            \vspace{-100pt}
        \end{wrapfigure}
        \vspace{-40pt}
        \paragraph{Optimality} A* algorithm can only find the optimal solution if the heuristic is admissible. We relaxed the rule to allow pieces to jump freely without the need to leapfrog another piece. Because jump move allows pieces to move twice the normal move, our heuristic at most underestimates the real cost by a factor of 2, and cannot be faster the real cost. This satisfied admissibility. Monotonicity is also satisfied because each move adds 1 unit of cost. Hence our program is optimal.
        \vspace{-10pt}
        \paragraph{Completeness} A* algorithm is complete if the graph contains finite nodes. For our problem, both the board and the number of pieces are finite therefore the state space must also be finite. Hence we can conclude that our program is complete.
    \section{Beyond}
        The number of moving pieces affects the complexity of the problem exponentially. This because with more pieces we have more possible moves and higher branching factors.\\
        The further pieces are from the goal, deeper the program has to search.\\
        A* algorithm stores each layer of nodes in a priority queue and only expend the $node$ $n$ with the $f(n)$. In the worst case, it expands all the nodes fully, store and sort them in order of cost. Which gives $O(b^d)$. In the best case, our heuristic matches the real cost, and A only expand nodes with the correct path. This gives us $O(bd)$. The high memory cost can be avoided by using iterative \textbf{deepening A search}. This would reduce A* algorithm's space complexity to $O(bd)$.
        
\end{document}
