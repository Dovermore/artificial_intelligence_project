\documentclass[11pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{setspace}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{listings}
\usepackage{hyperref}
\usepackage[left=1cm, right=1cm, top=1cm, bottom=2cm]{geometry}
\setstretch{0.5}

\algdef{SE}[SUBALG]{Indent}{EndIndent}{}{\algorithmicend\ }%
\algtext*{Indent}
\algtext*{EndIndent}

\newcommand{\algorithmautorefname}{Algorithm}

\begin{document}
    \begin{center}
        \large Problem, Search and beyond
        
        \normalsize Chuanyuna Liu 884140, Zhuoqun Huang 908525
    \end{center}
    \section{Problem}
    \subsection{General Problem}
    We formulate our problem with the following five concepts:
    \begin{itemize}
        \item \textbf{State($\mathbb{S}$)} including a \textbf{initial state ($s_0$)} the agent begins with
        \item \textbf{Actions($\mathbb{A}$)} available to agent at each State
        \item \textbf{Transition function ($F:\mathbb{S}\times \mathbb{A}\rightarrow \mathbb{S}$)} that takes a (state, action) pair and return a new state
        \item \textbf{Goal Test($GT:S\rightarrow \{True, False\}$)} that takes a state $s$ and return true if $s\in S_{goal}$, the \textbf{Goal State} of the problem.
        \item \textbf{Path Cost ($C:\mathbb{S}\times \mathbb{S}\rightarrow \mathbb{R}$)} That takes two states and return cost moving from one to another
    \end{itemize}
    \subsection{Single-player Chexers}
    In this section, we formally describe how the above framework fits the Chexers game.
    \begin{itemize}
        \item Denote set of pieces with $\mathbb{P}=\{(r, q, t)\}$. \\
        where
        \begin{align*}
            \text{$r, q, -(r+q)\in [-3, 3]$ denotes the location on board.}\\
            \text{$t\in \{red, blue, green, block\}$ stands for type of piece.}    
        \end{align*}
        
        \item $\mathbb{S} := \{p_i\in \mathbb{P}, t_b|i\le n\}$ where $n$ is number of pieces on board, where $t_b$ is the searching type.*
        \item $\mathbb{A} := \{(Move,p_i), (Jump, p_i), (Exit, p_i)\}, \forall\ p_i $ where$\ t(p_i)=t_b. | \mathbb{A}_s| \le 6n_p\ \forall s$.
        \item $f(s, a) := s'$. where $s'$ differs exactly by one piece $r(p_{i,s}), q(p_{i,s}) \ne r(p_{i,s'}), q(p_{i,s'})$ or $p_i\notin s'$
        \item $c(s, s') := 1, \forall s, s'\ \text{if}\ \exists a\ \text{such that} f(s, a) = s'$
        \item $gt(s) = True$ if $\nexists p_i$ such that $t(p_i) = t_b$
    \end{itemize}
    *Initial State $s_0$ given by problem specification.
    
    \section{Search}
    \subsection{preliminary}
    We use the following \autoref{a_star}, to search for our goal. Based on our problem specification, we have all required components except for \textbf{H($node$)}, so we will propose one type of \textbf{H} we found to be most effective of all and compare it against \textbf{Null $H=0$} and \textbf{bad H $H_{bad}$($node$)}.
    \begin{algorithm}[ht]
        \footnotesize
        \caption{General A* algorithm}\label{a_star}
        \begin{algorithmic}[1]
            \Statex PRIORITY-QUEUE \Comment{\textbf{Min} Priority Queue (min key)}
            \Statex  \hskip2.0em ADD($q$, $key$, $value$), \Comment{Add (key, value) to q. If value exists, update the key}
            \Statex  \hskip2.0em POP($q$) \Comment{Pop the value with \textbf{least} key}
            \Statex  \hskip2.0em GET($q$, $value$) \Comment{Get the key associated with a value}
            \Statex \Comment{All above Queue operations can operate in $\Theta(1)$}
            \Statex
            \Statex NODE \Comment{stores associated \textbf{state} and its \textbf{parent}}
            \Require EXPAND($node$)\Comment{expand a \textbf{node} to get it's \textbf{children}}
            \Require G($node$)\Comment{get \textbf{total cost} arriving this node}
            \Require H($node$) \Comment{Computes an \textbf{admissible estimation} of cost to goal state}
            \Require C($node1$, $node2$) \Comment{Give Path cost arriving node 2 from node 1}
            \Procedure{A*}{$problem$, $initial$}
            \State $openSet \gets$ PRIORITY-QUEUE(H($initial$),  $initial$)
            \State $closedSet \gets$ \{\}
            \While{$openSet$ \textbf{is not} empty} 
                \State $node \gets POP(openSet)$
                \State $ADD(closedSet, node)$
                \If {GOAL-TEST($node$) \textbf{is} True}
                    \State \textbf{return} $node$
                \EndIf
                \For {$child$ \textbf{in} EXPAND($node$)}
                    \State $cost$ = G($node$) + C($node$, $child$) + H($child$)
                    \If {$child$ \textbf{in} $closedSet$}
                        continue
                    \ElsIf {$child$ not in $openSet$ \textbf{or} cost $<$ GET($openSet$, $child$)}
                        \State ADD(openSet, cost, child)
                    \EndIf
                \EndFor
            \EndWhile
            \State \textbf{return} no solution
            \EndProcedure\\
            All operations $O(1)$ unless explicitly stated
        \end{algorithmic}
    \end{algorithm}
    \subsection{Heuristic}
    \paragraph{As a Problem} We propose the following problem definition for mapping a good heuristic value for each pieces and we define $H(s) = \sum_{p_i}h(p_i), \forall p_i$ that $t(p_i) = t_b$ after relaxing the problem to be: a piece can choose freely between \textbf{move}, \textbf{jump} regardless normal constrains and \textbf{cannot} move on blocks.
    \begin{itemize}        
        \item $\mathbb{S} := \{(cost_i, position_i)|location_i\in board\}$*,
        \item $\mathbb{A} :$ for $pos_i$ with $cost_i=min({cost_n})$, $\forall$ $pos_{j\ne i} $ reachable from $pos_i$ and $cost_j > cost_i+1$. Update $(pos_j, cost_i + 1)$. If $\nexists pos_j$, remove $(pos_i, cost_i)$ from $s$ and put $h(pos_i) = cost_i$
        \item $c(s, s')=0$ and $f(s,a)$ follows definition in $\mathbb{A}$
        \item $gt(s')=True$ if $s' = \emptyset$
    \end{itemize}
    *$s_0 = \{(1, pos_i)|can\_exit(pos_i) = True\} | \{(\infty, pos_i)|can\_exit(pos_i) = False\}$
    \paragraph{Heuristic problem solution} Finding heuristic is straight forward with the given above problem definition. Supporting all the given operations to \ref{a_star}, and you should end up with a complete heuristic map.
    \paragraph{Admissible?} The algorithm is guaranteed to provide us with a admissible cost estimation for each game state for the following reason:\\
    - The relaxed rule let pieces always able to jump. This will in all cases reduce the number of action taken.
    \subsection{The search}
    
    
    
\end{document}
